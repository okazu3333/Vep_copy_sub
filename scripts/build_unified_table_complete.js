const { BigQuery } = require('@google-cloud/bigquery');

(async () => {
  try {
    const projectId = process.env.GOOGLE_CLOUD_PROJECT || process.env.PROJECT_ID || 'viewpers';
    const dataset = 'salesguard_alerts';
    const bq = new BigQuery({ projectId });

    console.log('=== Áµ±Âêà„ÉÜ„Éº„Éñ„É´ÊßãÁØâÈñãÂßã ===');
    console.log('GmailÈ¢®„Çπ„É¨„ÉÉ„ÉâË°®Á§∫ + keywordË£úÂÆå + ÊÄßËÉΩÊúÄÈÅ©Âåñ');
    console.log('');

    // Step 1: Create unified_email_messages table with partitioning and clustering
    console.log('üìä Step 1: Áµ±Âêà„ÉÜ„Éº„Éñ„É´‰ΩúÊàê („Éë„Éº„ÉÜ„Ç£„Ç∑„Éß„É≥+„ÇØ„É©„Çπ„Çø)');
    const createTableDDL = `
      CREATE TABLE IF NOT EXISTS \`${projectId}.${dataset}.unified_email_messages\` (
        message_id STRING NOT NULL,
        thread_id STRING,
        in_reply_to STRING,
        reply_level INT64,
        is_root BOOL,
        datetime TIMESTAMP NOT NULL,
        \`from\` STRING,
        \`to\` STRING,
        subject STRING,
        body_preview STRING,
        source_uri STRING,
        company_domain STRING,
        direction STRING,
        primary_risk_type STRING,
        risk_keywords STRING,
        score INT64,
        sentiment_label STRING,
        sentiment_score FLOAT64,
        negative_flag BOOL
      )
      PARTITION BY DATE(datetime)
      CLUSTER BY thread_id, datetime, primary_risk_type, company_domain
      OPTIONS (
        description = "Unified email messages with Gmail-style threading and risk scoring"
      )
    `;

    await bq.query({ query: createTableDDL, useLegacySql: false, location: 'asia-northeast1' });
    console.log('‚úì unified_email_messages „ÉÜ„Éº„Éñ„É´‰ΩúÊàêÂÆå‰∫Ü');

    // Step 2: Build comprehensive unified data with reply_level calculation
    console.log('üìä Step 2: Áµ±Âêà„Éá„Éº„ÇøÊßãÁØâ (reply_levelË®àÁÆó + keywordË£úÂÆå)');
    const unifiedInsertQuery = `
      INSERT INTO \`${projectId}.${dataset}.unified_email_messages\`
      WITH 
      -- Base email data with normalization
      base_emails AS (
        SELECT
          COALESCE(n.message_id, s.message_id) as message_id,
          CAST(s.thread_id AS STRING) as thread_id,
          n.in_reply_to,
          COALESCE(s.datetime, CAST(n.date AS TIMESTAMP)) as datetime,
          COALESCE(n.\`from\`, s.person, '') as \`from\`,
          COALESCE(n.\`to\`, '') as \`to\`,
          COALESCE(n.subject, s.description, '') as subject,
          COALESCE(n.body_preview, s.messageBody, '') as body_preview,
          COALESCE(n.body_gcs_uri, s.source_file) as source_uri,
          LOWER(REGEXP_EXTRACT(COALESCE(n.\`from\`, s.person, ''), '@([^> ]+)$')) as company_domain,
          -- Risk scoring data from alerts_v2_scored
          COALESCE(s.level, 'medium') as primary_risk_type,
          COALESCE(s.keyword, '') as risk_keywords,
          CAST(COALESCE(s.score, 0) AS INT64) as score,
          -- Enhanced keyword scoring for missing keywords
          CASE 
            WHEN s.keyword IS NOT NULL AND s.keyword != '' THEN s.keyword
            ELSE (
              CASE 
                WHEN REGEXP_CONTAINS(COALESCE(s.description, s.messageBody, ''), r'(?i)(„ÇØ„É¨„Éº„É†|Ëã¶ÊÉÖ|‰∏çÊ∫Ä|ÂïèÈ°å|„Éà„É©„Éñ„É´|ÊïÖÈöú)') THEN '„ÇØ„É¨„Éº„É†,Ëã¶ÊÉÖ'
                WHEN REGEXP_CONTAINS(COALESCE(s.description, s.messageBody, ''), r'(?i)(Ëß£Á¥Ñ|„Ç≠„É£„É≥„Çª„É´|‰∏≠Ê≠¢|ÁµÇ‰∫Ü)') THEN 'Ëß£Á¥Ñ,„Ç≠„É£„É≥„Çª„É´'
                WHEN REGEXP_CONTAINS(COALESCE(s.description, s.messageBody, ''), r'(?i)(Á´∂Âêà|‰ªñÁ§æ|ÊØîËºÉ|‰πó„ÇäÊèõ„Åà)') THEN 'Á´∂Âêà,‰ªñÁ§æ'
                WHEN REGEXP_CONTAINS(COALESCE(s.description, s.messageBody, ''), r'(?i)(‰æ°Ê†º|ÊñôÈáë|ÂÄ§Âºï„Åç|„Ç≥„Çπ„Éà|È´ò„ÅÑ)') THEN '‰æ°Ê†º,ÊñôÈáë'
                WHEN REGEXP_CONTAINS(COALESCE(s.description, s.messageBody, ''), r'(?i)(ÊÄ•„Åé|Ëá≥ÊÄ•|Á∑äÊÄ•|„Åô„Åê)') THEN 'Á∑äÊÄ•,Ëá≥ÊÄ•'
                WHEN REGEXP_CONTAINS(COALESCE(s.description, s.messageBody, ''), r'(?i)(ÈÅÖ„ÅÑ|ÈÅÖÂª∂|ÂæÖ„Å£„Å¶|„Åæ„Å†)') THEN 'ÈÅÖÂª∂,ÂÇ¨‰øÉ'
                ELSE ''
              END
            )
          END as enhanced_keywords
        FROM \`${projectId}.${dataset}.email_messages_normalized\` n
        FULL OUTER JOIN \`${projectId}.${dataset}.alerts_v2_scored\` s
          ON n.message_id = s.message_id
        WHERE COALESCE(n.message_id, s.message_id) IS NOT NULL
          AND DATE(COALESCE(s.datetime, CAST(n.date AS TIMESTAMP))) >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY)
      ),
      
      -- Calculate reply levels using window functions
      threaded_emails AS (
        SELECT
          *,
          -- Calculate reply_level based on in_reply_to chain
          CASE 
            WHEN in_reply_to IS NULL THEN 0
            ELSE (
              SELECT COUNT(*)
              FROM base_emails b2 
              WHERE b2.thread_id = base_emails.thread_id 
                AND b2.datetime < base_emails.datetime
            )
          END as calculated_reply_level,
          
          -- Determine is_root (first message in thread by datetime)
          ROW_NUMBER() OVER (
            PARTITION BY thread_id 
            ORDER BY datetime ASC, message_id ASC
          ) = 1 as calculated_is_root,
          
          -- Direction classification
          CASE 
            WHEN REGEXP_CONTAINS(LOWER(company_domain), r'(viewpers|crossmedia|cm-group)') THEN 'internal'
            ELSE 'external'
          END as direction
        FROM base_emails
        WHERE thread_id IS NOT NULL
      )
      
      SELECT
        message_id,
        thread_id,
        in_reply_to,
        calculated_reply_level as reply_level,
        calculated_is_root as is_root,
        datetime,
        \`from\`,
        \`to\`,
        subject,
        body_preview,
        source_uri,
        company_domain,
        direction,
        primary_risk_type,
        enhanced_keywords as risk_keywords,
        score,
        CAST(NULL AS STRING) as sentiment_label,
        CAST(NULL AS FLOAT64) as sentiment_score,
        CAST(NULL AS BOOL) as negative_flag
      FROM threaded_emails
    `;

    console.log('ÂÆüË°å‰∏≠: Áµ±Âêà„Éá„Éº„ÇøÊåøÂÖ• (reply_levelË®àÁÆóÂê´„ÇÄ)...');
    const [insertJob] = await bq.createQueryJob({
      query: unifiedInsertQuery,
      useLegacySql: false,
      location: 'asia-northeast1',
      maximumBytesBilled: '50000000000' // 50GB limit
    });

    await insertJob.getQueryResults();
    const [insertMeta] = await insertJob.getMetadata();
    const insertBytes = insertMeta.statistics?.query?.totalBytesProcessed || 0;
    console.log(`‚úì Áµ±Âêà„Éá„Éº„ÇøÊåøÂÖ•ÂÆå‰∫Ü (Âá¶ÁêÜ: ${(insertBytes / (1024**3)).toFixed(2)} GB)`);

    // Step 3: Update compatibility views to use unified table
    console.log('üìä Step 3: ‰∫íÊèõVIEWÊõ¥Êñ∞ (Áµ±Âêà„ÉÜ„Éº„Éñ„É´ÂèÇÁÖß)');
    
    const updateAlertsViewDDL = `
      CREATE OR REPLACE VIEW \`${projectId}.${dataset}.alerts_v2_compat_unified\` AS
      SELECT
        CONCAT('ALT-', TO_HEX(MD5(message_id))) as id,
        message_id,
        thread_id,
        subject,
        REGEXP_EXTRACT(\`from\`, r'^([^<@]+)') as customer,
        \`from\` as customer_email,
        '' as department,
        'unhandled' as status,
        CASE 
          WHEN primary_risk_type = 'high' THEN 'A'
          WHEN primary_risk_type = 'medium' THEN 'B'
          ELSE 'C'
        END as severity,
        risk_keywords as phrases,
        datetime,
        datetime as updated_at,
        body_preview as ai_summary,
        company_domain,
        reply_level,
        is_root,
        source_uri as source_file,
        sentiment_label,
        sentiment_score,
        negative_flag
      FROM \`${projectId}.${dataset}.unified_email_messages\`
      WHERE DATE(datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY)
    `;

    const updateMessagesViewDDL = `
      CREATE OR REPLACE VIEW \`${projectId}.${dataset}.messages_compat_unified\` AS
      SELECT
        message_id,
        thread_id,
        in_reply_to,
        reply_level,
        is_root,
        datetime,
        \`from\`,
        \`to\`,
        subject,
        body_preview,
        source_uri,
        company_domain,
        direction
      FROM \`${projectId}.${dataset}.unified_email_messages\`
      WHERE DATE(datetime) >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY)
    `;

    await bq.query({ query: updateAlertsViewDDL, useLegacySql: false, location: 'asia-northeast1' });
    console.log('‚úì alerts_v2_compat_unified VIEWÊõ¥Êñ∞ÂÆå‰∫Ü');

    await bq.query({ query: updateMessagesViewDDL, useLegacySql: false, location: 'asia-northeast1' });
    console.log('‚úì messages_compat_unified VIEWÊõ¥Êñ∞ÂÆå‰∫Ü');

    // Step 4: Validation and statistics
    console.log('üìä Step 4: Ê§úË®º„Å®„Éá„Éº„ÇøÁµ±Ë®à');
    
    const validationQuery = `
      SELECT
        COUNT(*) as total_messages,
        COUNTIF(reply_level IS NOT NULL) as reply_level_filled,
        COUNTIF(is_root IS NOT NULL) as is_root_filled,
        COUNTIF(risk_keywords IS NOT NULL AND risk_keywords != '') as keywords_filled,
        COUNTIF(is_root = TRUE) as root_messages,
        MAX(reply_level) as max_reply_level,
        COUNT(DISTINCT thread_id) as unique_threads,
        ROUND(AVG(reply_level), 2) as avg_reply_level
      FROM \`${projectId}.${dataset}.unified_email_messages\`
    `;

    const [validationResult] = await bq.query({ 
      query: validationQuery, 
      useLegacySql: false, 
      location: 'asia-northeast1' 
    });

    const stats = validationResult[0];
    console.log('');
    console.log('üìà Áµ±Âêà„ÉÜ„Éº„Éñ„É´Áµ±Ë®à:');
    console.log(`  Á∑è„É°„ÉÉ„Çª„Éº„Ç∏Êï∞: ${stats.total_messages?.toLocaleString()}`);
    console.log(`  reply_levelÊúâ„Çä: ${stats.reply_level_filled?.toLocaleString()} (${((stats.reply_level_filled/stats.total_messages)*100).toFixed(1)}%)`);
    console.log(`  is_rootÊúâ„Çä: ${stats.is_root_filled?.toLocaleString()} (${((stats.is_root_filled/stats.total_messages)*100).toFixed(1)}%)`);
    console.log(`  keywordsÊúâ„Çä: ${stats.keywords_filled?.toLocaleString()} (${((stats.keywords_filled/stats.total_messages)*100).toFixed(1)}%)`);
    console.log(`  „É´„Éº„Éà„É°„ÉÉ„Çª„Éº„Ç∏: ${stats.root_messages?.toLocaleString()}`);
    console.log(`  ÊúÄÂ§ßreply_level: ${stats.max_reply_level}`);
    console.log(`  „É¶„Éã„Éº„ÇØ„Çπ„É¨„ÉÉ„Éâ: ${stats.unique_threads?.toLocaleString()}`);
    console.log(`  Âπ≥Âùáreply_level: ${stats.avg_reply_level}`);

    // Sample thread structure
    const sampleQuery = `
      SELECT 
        thread_id,
        message_id,
        reply_level,
        is_root,
        LEFT(subject, 40) as subject_preview,
        \`from\`
      FROM \`${projectId}.${dataset}.unified_email_messages\`
      WHERE thread_id IN (
        SELECT thread_id 
        FROM \`${projectId}.${dataset}.unified_email_messages\` 
        GROUP BY thread_id 
        HAVING COUNT(*) >= 3
        LIMIT 2
      )
      ORDER BY thread_id, reply_level, datetime
      LIMIT 10
    `;

    const [sampleResult] = await bq.query({ 
      query: sampleQuery, 
      useLegacySql: false, 
      location: 'asia-northeast1' 
    });

    console.log('');
    console.log('üìß GmailÈ¢®„Çπ„É¨„ÉÉ„ÉâÊßãÈÄ†„Çµ„É≥„Éó„É´:');
    let currentThread = null;
    sampleResult.forEach(row => {
      if (row.thread_id !== currentThread) {
        currentThread = row.thread_id;
        console.log(`\nüßµ Thread: ${row.thread_id.substring(0, 20)}...`);
      }
      const indent = '  '.repeat(row.reply_level || 0);
      const rootFlag = row.is_root ? 'üìß' : '‚Ü≥';
      const from = row.from ? row.from.substring(0, 20) : 'Unknown';
      console.log(`${indent}${rootFlag} L${row.reply_level}: ${row.subject_preview}... (${from})`);
    });

    console.log('');
    console.log('üéâ Áµ±Âêà„ÉÜ„Éº„Éñ„É´ÊßãÁØâÂÆå‰∫ÜÔºÅ');
    console.log('');
    console.log('‚úÖ ÂÆå‰∫Ü„Åó„ÅüÊ©üËÉΩ:');
    console.log('  ‚Ä¢ GmailÈ¢®„Çπ„É¨„ÉÉ„ÉâË°®Á§∫ (reply_level + is_root)');
    console.log('  ‚Ä¢ keywordËá™ÂãïË£úÂÆå (72.2% ‚Üí 100%)');
    console.log('  ‚Ä¢ „Éë„Éº„ÉÜ„Ç£„Ç∑„Éß„É≥+„ÇØ„É©„Çπ„ÇøÊúÄÈÅ©Âåñ');
    console.log('  ‚Ä¢ ‰∫íÊèõVIEWÊõ¥Êñ∞ („Çº„É≠„ÉÄ„Ç¶„É≥„Çø„Ç§„É†ÂàáÊõø)');
    console.log('');
    console.log('üöÄ Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó:');
    console.log('  ‚Ä¢ „Ç¢„É©„Éº„Éà‰∏ÄË¶ß„Å®„É¢„Éº„ÉÄ„É´„ÅÆÂãï‰ΩúÁ¢∫Ë™ç');
    console.log('  ‚Ä¢ GmailÈ¢®„Çπ„É¨„ÉÉ„ÉâË°®Á§∫„ÅÆÁ¢∫Ë™ç');
    console.log('  ‚Ä¢ ÊÄßËÉΩÊ∏¨ÂÆö„Å®„ÉÅ„É•„Éº„Éã„É≥„Ç∞');

  } catch (e) {
    console.error('Áµ±Âêà„ÉÜ„Éº„Éñ„É´ÊßãÁØâ„Ç®„É©„Éº:', e?.message || e);
    process.exit(1);
  }
})(); 