# 汎用自動検知・セグメント化システム設計

## 質問への回答

### Q: ユースケース追加のたびに、毎回新しい検知モデルを手動で作る必要があるのか？

**A: いいえ。汎用的な自動検知システムを構築すれば、新しいユースケースを追加する際も、指標の組み合わせを定義するだけで自動検知・分類が可能です。**

### Q: 予兆、発生、回復の大項目に当たりそうなユースケースを自動検知し、セグメント化することは可能か？

**A: はい、可能です。多段階分類システムと汎用的な検知ルールエンジンで実現できます。**

## 汎用自動検知システムの設計

### 1. 多段階分類システム

```
Step 1: カテゴリ分類（予兆/発生/回復）
   ↓
Step 2: セグメント分類（具体的なセグメント）
   ↓
Step 3: 信頼度評価
```

### 2. 汎用的な検知ルールエンジン

#### アプローチA: ルールベース（推奨）
- **特徴**: 指標の組み合わせで判定
- **メリット**: 解釈可能、調整しやすい
- **実装**: SQLビューまたはTypeScript関数

#### アプローチB: 機械学習
- **特徴**: 過去データから学習
- **メリット**: 自動的にパターンを発見
- **実装**: 教師あり学習モデル

#### アプローチC: ハイブリッド（推奨）
- **特徴**: ルール + ML
- **メリット**: 両方の長所を活用
- **実装**: ルールベースで基本分類、MLで精度向上

### 3. 動的なルール追加

新しいユースケース追加時の手順：
1. ユースケースの特徴を分析
2. 必要な指標を選択
3. 指標の閾値・条件を定義
4. 汎用検知エンジンにルール追加（設定ファイルまたはDB）
5. 自動検知・分類開始

## 必要な物差し（指標）

### 📏 必須指標（すべてのセグメントで使用）

#### 1. 感情・トーンの指標
- **sentiment_score**: 感情スコア（-1.0 〜 1.0）
  - 用途: ネガティブ/ポジティブの判定
  - 閾値例: < -0.3（ネガティブ）、> 0.3（ポジティブ）

- **sentiment_drop**: 感情スコアの低下率
  - 用途: トーンダウンの検知
  - 計算: 過去30日平均 - 過去7日平均

- **sentiment_trend**: 感情スコアの傾向
  - 値: 上昇/下降/横ばい
  - 用途: 長期的な傾向の把握

#### 2. 時間軸の指標
- **hours_since_last_activity**: 最後の活動からの経過時間
  - 用途: 放置、沈黙の検知
  - 閾値例: 72時間（放置）、48時間（沈黙）

- **time_pattern**: 時間パターン
  - 値: 即時 / 継続的 / 過去履歴照合
  - 用途: セグメント分類の補助

- **response_time**: 返信までの時間
  - 用途: 対応品質の評価

#### 3. コミュニケーションの指標
- **direction**: メールの方向性
  - 値: inbound（顧客→営業）/ outbound（営業→顧客）
  - 用途: ボールの所在判定

- **reply_frequency**: 返信頻度
  - 計算: 過去7日の返信数 / 過去30日の返信数
  - 用途: トーンダウンの検知

- **response_ratio**: 返信率
  - 計算: 返信数 / 受信数
  - 用途: 対応状況の評価

- **night_reply_rate**: 夜間返信率
  - 計算: 夜間返信数 / 総返信数
  - 用途: 対応品質の評価

#### 4. キーワード・文脈の指標
- **urgency_keywords**: 催促系キーワード
  - 例: 「至急」「いつまで」「まだですか」
  - 用途: 催促の検知

- **complaint_keywords**: 不満系キーワード
  - 例: 「クレーム」「不満」「問題」
  - 用途: 不満の検知

- **inquiry_keywords**: 問い合わせ系キーワード
  - 例: 「確認」「質問」「お願い」
  - 用途: 問い合わせの検知

- **context**: 文脈情報
  - 値: 提案後、契約後、対応後など
  - 用途: セグメント分類の補助

### 📏 補助指標（セグメントによって使用）

#### 5. 行動パターンの指標
- **alert_history**: 過去のアラート履歴
  - 用途: 再発の検知
  - データ: 過去のアラート解決履歴

- **reoccurrence_flag**: 再発フラグ
  - 計算: 過去のアラートと類似度
  - 用途: 再発の検知

- **interaction_pattern**: やり取りのパターン
  - 値: 頻繁/稀、短い/長い、フォーマル/カジュアル
  - 用途: セグメント分類の補助

## カテゴリ別の分類ロジック

### 予兆（forecast）の判定

**特徴**:
- 時間パターン: 継続的・予兆的
- 緊急度: 低〜中
- 方向性: inbound/outbound両方

**判定条件**:
```typescript
if (
  (sentiment_drop < -0.2 && reply_frequency < 0.5) ||  // トーンダウン
  (hours_since_last_activity >= 72 && direction === 'inbound') ||  // 放置
  (night_reply_rate > 0.5) ||  // 対応品質
  (sentiment_score < -0.2 && inquiry_keywords.length > 0)  // 信頼リスク
) {
  category = 'forecast'
}
```

### 発生（occurrence）の判定

**特徴**:
- 時間パターン: 即時・明確
- 緊急度: 高
- 方向性: 主にinbound

**判定条件**:
```typescript
if (
  (sentiment_score < -0.3 && urgency_keywords.length > 0) ||  // 催促
  (sentiment_score < -0.4 && complaint_keywords.length > 0) ||  // 不満
  (hours_since_last_activity >= 48 && direction === 'outbound') ||  // 沈黙
  (proposal_keywords.length > 0 && sentiment_score < -0.2) ||  // 提案差異
  (reoccurrence_flag === true)  // 再発
) {
  category = 'occurrence'
}
```

### 回復（follow）の判定

**特徴**:
- 時間パターン: 対応後
- 緊急度: 低
- 方向性: inbound（ポジティブ）

**判定条件**:
```typescript
if (
  (previous_segment === 'occurrence' && sentiment_score > 0) ||  // 発生後のポジティブ反応
  (status === 'in_progress' && hours_since_last_activity >= 24)  // 対応後24時間以上
) {
  category = 'follow'
}
```

## セグメント分類の具体例

### 例1: トーンダウン（forecast_tone_down）

**必要な指標**:
- sentiment_drop < -0.2
- reply_frequency < 0.5
- time_pattern = '継続的'

**判定ロジック**:
```sql
SELECT 
  thread_id,
  'forecast_tone_down' AS segment,
  CASE 
    WHEN sentiment_drop < -0.2 AND frequency_ratio < 0.5 THEN 1
    ELSE 0
  END AS should_detect
FROM thread_metrics
```

### 例2: 提案差異（occurrence_proposal_issue）

**必要な指標**:
- proposal_keywords: ['修正', '変更', '違う', '期待', '要望', '確認不足', '資料', '再共有']
- sentiment_score < -0.2
- context = '提案後'

**判定ロジック**:
```sql
SELECT 
  thread_id,
  'occurrence_proposal_issue' AS segment,
  CASE 
    WHEN sentiment_score < -0.2 
      AND (
        REGEXP_CONTAINS(text, r'(修正|変更|違う|期待|要望|確認不足|資料|再共有)')
        OR proposal_keywords_count > 0
      )
      AND context = 'proposal_after'
    THEN 1
    ELSE 0
  END AS should_detect
FROM message_analysis
```

## 実装アーキテクチャ

### 1. 汎用検知エンジン

```typescript
interface DetectionRule {
  id: string;
  segment: SegmentKey;
  category: SegmentCategoryKey;
  conditions: DetectionCondition[];
  priority: number;
  confidence_threshold: number;
}

interface DetectionCondition {
  metric: string;  // 'sentiment_score', 'hours_since_last_activity', etc.
  operator: 'gt' | 'lt' | 'eq' | 'contains' | 'regex';
  value: number | string | string[];
  weight: number;  // 条件の重み
}

class UniversalDetectionEngine {
  async detectSegment(message: EmailMessage, context: Context): Promise<SegmentDetection> {
    // 1. 指標を計算
    const metrics = await this.calculateMetrics(message, context);
    
    // 2. カテゴリを分類
    const category = await this.classifyCategory(metrics);
    
    // 3. セグメントを分類
    const segment = await this.classifySegment(metrics, category);
    
    // 4. 信頼度を評価
    const confidence = await this.calculateConfidence(metrics, segment);
    
    return { segment, category, confidence, metrics };
  }
}
```

### 2. ルール定義（設定ファイルまたはDB）

```json
{
  "detection_rules": [
    {
      "id": "forecast_tone_down",
      "segment": "forecast_tone_down",
      "category": "forecast",
      "conditions": [
        {
          "metric": "sentiment_drop",
          "operator": "lt",
          "value": -0.2,
          "weight": 0.5
        },
        {
          "metric": "reply_frequency",
          "operator": "lt",
          "value": 0.5,
          "weight": 0.5
        }
      ],
      "priority": 1,
      "confidence_threshold": 0.7
    },
    {
      "id": "occurrence_proposal_issue",
      "segment": "occurrence_proposal_issue",
      "category": "occurrence",
      "conditions": [
        {
          "metric": "sentiment_score",
          "operator": "lt",
          "value": -0.2,
          "weight": 0.3
        },
        {
          "metric": "proposal_keywords",
          "operator": "contains",
          "value": ["修正", "変更", "違う", "期待", "要望", "確認不足", "資料", "再共有"],
          "weight": 0.7
        }
      ],
      "priority": 2,
      "confidence_threshold": 0.6
    }
  ]
}
```

## 新しいユースケース追加時の手順

### ステップ1: ユースケースの特徴を分析
- どのような状況で発生するか？
- どのような指標で検知できるか？
- 予兆/発生/回復のどれに該当するか？

### ステップ2: 必要な指標を選択
- 必須指標から選択
- 補助指標から選択
- 必要に応じて新しい指標を追加

### ステップ3: 指標の閾値・条件を定義
- 各指標の閾値を設定
- 条件の組み合わせを定義
- 重みを調整

### ステップ4: 汎用検知エンジンにルール追加
- 設定ファイルまたはDBにルールを追加
- 既存の検知エンジンが自動的に適用

### ステップ5: 自動検知・分類開始
- 新しいルールが自動的に適用される
- 手動でコードを変更する必要がない

## まとめ

✅ **汎用的な自動検知システムは可能**
- 多段階分類システム
- 汎用的な検知ルールエンジン
- 動的なルール追加

✅ **必要な物差し（指標）は明確**
- 必須指標: 感情、時間、コミュニケーション、キーワード
- 補助指標: 行動パターン、過去履歴

✅ **新しいユースケース追加が容易**
- 指標の組み合わせを定義するだけ
- コード変更不要
- 設定ファイルまたはDBで管理

