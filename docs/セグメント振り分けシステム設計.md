# セグメント振り分けシステム設計

## 設計方針

### 1. 多段階分類システム

```
Step 1: 指標計算
   ↓
Step 2: カテゴリ分類（予兆/発生/回復）
   ↓
Step 3: セグメント分類（具体的なセグメント）
   ↓
Step 4: 信頼度評価
   ↓
Step 5: 優先順位付け・最終決定
```

### 2. 優先順位ベースの分類（推奨）

**理由**:
- 複数のセグメントに該当する場合の処理が明確
- 緊急度の高いセグメントを優先
- 実装がシンプル

**処理フロー**:
1. すべてのセグメントルールを評価
2. 該当するセグメントをリストアップ
3. 優先順位が高いセグメントを選択
4. 信頼度が閾値以上の場合に採用

## セグメント優先順位の定義

### 優先順位の考え方

**基本原則**:
- **発生 > 予兆 > 回復**: 発生している問題を最優先
- **緊急度の高いもの優先**: 同じカテゴリ内では緊急度で判定
- **明確なもの優先**: 信頼度が高いものを優先

### セグメント優先順位表

| 優先順位 | セグメント | カテゴリ | 緊急度 | 理由 |
|---------|----------|---------|--------|------|
| 1 | `occurrence_complaint` | 発生 | 高 | 不満は即座に対応が必要 |
| 2 | `occurrence_followup` | 発生 | 高 | 催促は緊急対応が必要 |
| 3 | `occurrence_proposal_issue` | 発生 | 中 | 提案差異は早急な対応が必要 |
| 4 | `occurrence_silence` | 発生 | 中 | 沈黙は対応が必要 |
| 5 | `occurrence_reoccurrence` | 発生 | 中 | 再発は対応が必要 |
| 6 | `forecast_inactive` | 予兆 | 中 | 放置は問題の前兆 |
| 7 | `forecast_trust_risk` | 予兆 | 中 | 信頼リスクは早めに対応 |
| 8 | `forecast_tone_down` | 予兆 | 低 | トーンダウンは継続監視 |
| 9 | `forecast_response_quality` | 予兆 | 低 | 対応品質は継続改善 |
| 10 | `follow_recovery` | 回復 | 低 | 回復確認はフォロー段階 |

## 実装方法

### 方法1: 優先順位ベースの分類（推奨）

```typescript
interface SegmentRule {
  segment: SegmentKey;
  category: SegmentCategoryKey;
  priority: number;  // 1-10（1が最優先）
  conditions: DetectionCondition[];
  confidence_threshold: number;  // 0-1
  min_confidence: number;  // 最小信頼度
}

interface SegmentClassificationResult {
  segment: SegmentKey;
  category: SegmentCategoryKey;
  confidence: number;
  score: number;
  matched_conditions: string[];
  reason: string;
}

class SegmentClassifier {
  private rules: SegmentRule[];
  
  async classify(metrics: DetectionMetrics, context: Context): Promise<SegmentClassificationResult | null> {
    // 1. すべてのルールを評価
    const candidates: SegmentClassificationResult[] = [];
    
    for (const rule of this.rules) {
      const result = await this.evaluateRule(rule, metrics, context);
      if (result && result.confidence >= rule.min_confidence) {
        candidates.push(result);
      }
    }
    
    // 2. 優先順位でソート（優先順位が高い = 数値が小さい）
    candidates.sort((a, b) => {
      const priorityA = this.getPriority(a.segment);
      const priorityB = this.getPriority(b.segment);
      
      if (priorityA !== priorityB) {
        return priorityA - priorityB;  // 優先順位が高いものを優先
      }
      
      // 優先順位が同じ場合は信頼度で判定
      return b.confidence - a.confidence;
    });
    
    // 3. 最も優先順位が高く、信頼度が閾値以上のものを選択
    const best = candidates[0];
    if (best && best.confidence >= best.confidence_threshold) {
      return best;
    }
    
    return null;
  }
  
  private getPriority(segment: SegmentKey): number {
    const priorityMap: Record<SegmentKey, number> = {
      'occurrence_complaint': 1,
      'occurrence_followup': 2,
      'occurrence_proposal_issue': 3,
      'occurrence_silence': 4,
      'occurrence_reoccurrence': 5,
      'forecast_inactive': 6,
      'forecast_trust_risk': 7,
      'forecast_tone_down': 8,
      'forecast_response_quality': 9,
      'follow_recovery': 10,
    };
    return priorityMap[segment] || 99;
  }
}
```

### 方法2: カテゴリ→セグメントの2段階分類

```typescript
class TwoStageSegmentClassifier {
  async classify(metrics: DetectionMetrics, context: Context): Promise<SegmentClassificationResult | null> {
    // Step 1: カテゴリ分類
    const category = await this.classifyCategory(metrics, context);
    
    // Step 2: カテゴリ内でセグメント分類
    const segmentRules = this.rules.filter(r => r.category === category);
    const candidates: SegmentClassificationResult[] = [];
    
    for (const rule of segmentRules) {
      const result = await this.evaluateRule(rule, metrics, context);
      if (result && result.confidence >= rule.min_confidence) {
        candidates.push(result);
      }
    }
    
    // 優先順位でソート
    candidates.sort((a, b) => {
      const priorityA = this.getPriority(a.segment);
      const priorityB = this.getPriority(b.segment);
      return priorityA - priorityB;
    });
    
    return candidates[0] || null;
  }
  
  private async classifyCategory(metrics: DetectionMetrics, context: Context): Promise<SegmentCategoryKey> {
    // 発生の判定（最優先）
    if (
      (metrics.sentiment_score < -0.3 && metrics.urgency_keywords.length > 0) ||
      (metrics.sentiment_score < -0.4 && metrics.complaint_keywords.length > 0) ||
      (metrics.hours_since_last_activity >= 48 && metrics.direction === 'outbound')
    ) {
      return 'occurrence';
    }
    
    // 回復の判定
    if (
      (context.previous_segment?.startsWith('occurrence') && metrics.sentiment_score > 0) ||
      (context.status === 'in_progress' && metrics.hours_since_last_activity >= 24)
    ) {
      return 'follow';
    }
    
    // 予兆の判定（デフォルト）
    return 'forecast';
  }
}
```

### 方法3: スコアリングベースの分類

```typescript
class ScoringBasedSegmentClassifier {
  async classify(metrics: DetectionMetrics, context: Context): Promise<SegmentClassificationResult | null> {
    const scores: Map<SegmentKey, number> = new Map();
    
    // 各セグメントに対してスコアを計算
    for (const rule of this.rules) {
      const score = await this.calculateScore(rule, metrics, context);
      scores.set(rule.segment, score);
    }
    
    // 最もスコアが高いセグメントを選択
    let bestSegment: SegmentKey | null = null;
    let bestScore = 0;
    
    for (const [segment, score] of scores.entries()) {
      if (score > bestScore) {
        bestScore = score;
        bestSegment = segment;
      }
    }
    
    if (bestSegment && bestScore >= this.minScore) {
      return {
        segment: bestSegment,
        category: this.getCategory(bestSegment),
        confidence: bestScore / 100,
        score: bestScore,
        matched_conditions: [],
        reason: `スコア: ${bestScore}`,
      };
    }
    
    return null;
  }
  
  private async calculateScore(rule: SegmentRule, metrics: DetectionMetrics, context: Context): Promise<number> {
    let score = 0;
    let matchedCount = 0;
    
    for (const condition of rule.conditions) {
      const conditionScore = await this.evaluateCondition(condition, metrics, context);
      if (conditionScore > 0) {
        score += conditionScore * condition.weight;
        matchedCount++;
      }
    }
    
    // 優先順位を考慮（優先順位が高い = ボーナス）
    const priorityBonus = (11 - this.getPriority(rule.segment)) * 5;
    score += priorityBonus;
    
    // 信頼度を考慮
    const confidence = matchedCount / rule.conditions.length;
    score *= confidence;
    
    return Math.min(score, 100);
  }
}
```

## ルール定義（設定ファイル）

```json
{
  "segment_rules": [
    {
      "segment": "occurrence_complaint",
      "category": "occurrence",
      "priority": 1,
      "conditions": [
        {
          "metric": "sentiment_score",
          "operator": "lt",
          "value": -0.4,
          "weight": 0.4
        },
        {
          "metric": "complaint_keywords",
          "operator": "contains",
          "value": ["クレーム", "不満", "問題", "トラブル", "不具合", "エラー"],
          "weight": 0.6
        }
      ],
      "confidence_threshold": 0.7,
      "min_confidence": 0.6
    },
    {
      "segment": "occurrence_followup",
      "category": "occurrence",
      "priority": 2,
      "conditions": [
        {
          "metric": "sentiment_score",
          "operator": "lt",
          "value": -0.3,
          "weight": 0.3
        },
        {
          "metric": "urgency_keywords",
          "operator": "contains",
          "value": ["至急", "いつまで", "まだですか", "対応して", "返事がない"],
          "weight": 0.7
        }
      ],
      "confidence_threshold": 0.6,
      "min_confidence": 0.5
    },
    {
      "segment": "occurrence_proposal_issue",
      "category": "occurrence",
      "priority": 3,
      "conditions": [
        {
          "metric": "sentiment_score",
          "operator": "lt",
          "value": -0.2,
          "weight": 0.3
        },
        {
          "metric": "proposal_keywords",
          "operator": "contains",
          "value": ["修正", "変更", "違う", "期待", "要望", "確認不足", "資料", "再共有"],
          "weight": 0.7
        },
        {
          "metric": "context",
          "operator": "eq",
          "value": "proposal_after",
          "weight": 0.2
        }
      ],
      "confidence_threshold": 0.6,
      "min_confidence": 0.5
    },
    {
      "segment": "forecast_inactive",
      "category": "forecast",
      "priority": 6,
      "conditions": [
        {
          "metric": "hours_since_last_activity",
          "operator": "gte",
          "value": 72,
          "weight": 0.8
        },
        {
          "metric": "direction",
          "operator": "eq",
          "value": "inbound",
          "weight": 0.2
        }
      ],
      "confidence_threshold": 0.7,
      "min_confidence": 0.6
    },
    {
      "segment": "forecast_tone_down",
      "category": "forecast",
      "priority": 8,
      "conditions": [
        {
          "metric": "sentiment_drop",
          "operator": "lt",
          "value": -0.2,
          "weight": 0.5
        },
        {
          "metric": "reply_frequency",
          "operator": "lt",
          "value": 0.5,
          "weight": 0.5
        }
      ],
      "confidence_threshold": 0.7,
      "min_confidence": 0.6
    }
  ]
}
```

## 実装推奨

### 推奨アプローチ: 優先順位ベースの分類 + スコアリング

**理由**:
1. **明確な優先順位**: 複数のセグメントに該当する場合の処理が明確
2. **柔軟な調整**: スコアリングで細かい調整が可能
3. **拡張性**: 新しいセグメントを追加しやすい
4. **保守性**: ルールを設定ファイルで管理

**実装ステップ**:
1. セグメント優先順位を定義
2. 各セグメントのルールを定義（設定ファイル）
3. 優先順位ベースの分類器を実装
4. スコアリング機能を追加
5. 信頼度評価を実装

## まとめ

✅ **推奨方法**: 優先順位ベースの分類 + スコアリング
- すべてのセグメントルールを評価
- 優先順位が高いセグメントを選択
- 信頼度が閾値以上の場合に採用

✅ **実装場所**: 
- `lib/segment-classifier.ts` - 分類ロジック
- `config/segment-rules.json` - ルール定義

✅ **メリット**:
- コード変更不要で新しいセグメントを追加可能
- 優先順位が明確
- 複数のセグメントに該当する場合の処理が明確

