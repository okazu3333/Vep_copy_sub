# 検知モデル 実現性・コスト分析

## 1. 不足データを補完する元データの有無

### ✅ 既存データで補完可能な項目

#### 時間帯データ
- **元データ**: `unified_email_messages.datetime` (TIMESTAMP型)
- **取得方法**: `EXTRACT(HOUR FROM datetime)` で時間帯抽出可能
- **補完作業**: SQL集計で夜間返信率等を計算可能
- **データ品質**: ✅ 完全（全メッセージにdatetime存在）

#### 返信頻度・パターン
- **元データ**: 
  - `unified_email_messages.datetime`, `thread_id`, `reply_level`
  - `alerts_v2_scored` の担当者情報 (`person`, `assigned_user_id`)
- **取得方法**: 
  - 過去30日/90日の返信頻度は `datetime` と `thread_id` から集計可能
  - 担当者別統計は `person` でグルーピング
- **補完作業**: 集計ビューまたはマテリアライズドビュー作成
- **データ品質**: ✅ 良好（datetime、thread_id、personが揃っている）

#### トーンの時系列変化
- **元データ**: 
  - `unified_email_messages.sentiment_score` (FLOAT64)
  - `datetime`, `thread_id`, `person`
- **取得方法**: 
  - 過去30日のロールングウィンドウで平均感情スコア計算
  - トレンド判定（増加/減少/横ばい）もSQLで実装可能
- **補完作業**: 時系列分析用ビュー作成
- **データ品質**: ✅ 良好（sentiment_score、datetimeが存在）

#### 72時間放置検知
- **元データ**: 
  - `unified_email_messages.datetime` (最終アクティビティ)
  - `thread_id`, `reply_level`, `direction`
- **取得方法**: 
  - `MAX(datetime) OVER (PARTITION BY thread_id)` で最終アクティビティ取得
  - `CURRENT_TIMESTAMP() - MAX(datetime)` で経過時間計算
- **補完作業**: 放置検知用ビューまたは定期バッチ処理
- **データ品質**: ✅ 完全（datetime、thread_idが揃っている）

#### 感情ダウン + 催促ワードの組み合わせ
- **元データ**: 
  - `unified_email_messages.sentiment_score`
  - `risk_keywords` (既存キーワードマッチング結果)
  - `subject`, `body_preview`
- **取得方法**: 
  - sentiment_score < -0.3 で感情ダウン判定
  - 催促ワードは既存の `risk_keywords` または `subject`/`body_preview` の正規表現マッチ
- **補完作業**: 組み合わせ検知ロジックの実装
- **データ品質**: ✅ 良好（必要なデータは揃っている）

#### 催促フレーズの具体的検知
- **元データ**: `subject`, `body_preview` (STRING)
- **取得方法**: 
  - 正規表現パターンマッチングで「進捗いかがでしょ」等を検出
  - またはN-gram + 文脈解析（新規実装）
- **補完作業**: パターン定義とマッチングロジック追加
- **データ品質**: ✅ 良好（テキストデータは存在）

### ⚠️ 新規計算・推測が必要な項目

#### 対応品質の定量化
- **現状データ**: 返信文テキスト (`body_preview`, `message_body`)
- **不足**: 品質評価スコア（新規計算が必要）
- **実装方法**:
  - 文字数、丁寧語の使用率、質問への回答有無をNLPで抽出
  - 既存の `lib/japanese-nlp-analyzer.ts` などを拡張
- **推定コスト**: 中（既存NLPライブラリ活用、計算ロジック追加のみ）

#### 「不安・違和感」の具体的検知
- **現状データ**: テキスト (`subject`, `body_preview`)
- **不足**: 「念のため確認ですが」等の特定フレーズパターン定義
- **実装方法**:
  - 確認系フレーズの辞書作成
  - 既存の `keyword-detector.ts` を拡張
- **推定コスト**: 低（辞書追加とパターンマッチングのみ）

#### 夜間返信率の異常検知（担当者別ベースライン）
- **現状データ**: `datetime`, `person` は存在
- **不足**: 担当者別の過去パターン（通常20%等）のベースライン
- **実装方法**:
  - 過去90日の集計で担当者別の平均夜間返信率を計算
  - 現在の値との比較で異常検知
- **推定コスト**: 低（集計SQL追加のみ）

#### 予兆検知（アラート前段階）
- **現状データ**: メール送受信履歴 (`datetime`, `thread_id`, `direction`)
- **不足**: 頻度変化の検知ロジック（過去パターンとの比較）
- **実装方法**:
  - 過去7日 vs 過去30日の平均送受信頻度を比較
  - 急激な変化を検知
- **推定コスト**: 中（時系列分析ロジックの実装）

#### 対応品質の「後日フォロー」による検証
- **現状データ**: 基本的な対応履歴のみ
- **不足**: 顧客満足度の後追いデータ、質問への回答率の自動判定
- **実装方法**:
  - 顧客からの追加質問が来た場合 = 回答不足と判定
  - スレッド継続率から品質を推測
- **推定コスト**: 中（スレッド分析ロジック追加）

### ❌ 現状データでは難しい項目

#### 顧客満足度の直接データ
- **現状**: メール内の満足度言及のみ（NLPで抽出可能）
- **課題**: 明示的なCSAT調査結果は未取得
- **代替**: 感情スコアと返信頻度から推測可能

#### リソース分配の判断データ
- **現状**: 担当者の処理件数、対応時間は計算可能
- **不足**: 担当者のスキルレベル、業務負荷の定量的データ
- **代替**: 対応時間、夜間返信率、顧客からの再問い合わせ率から推測

---

## 2. それ以外の検知機能の設計可能性

### ✅ 設計・実装可能な検知機能

#### 1. 「感情ダウン + 催促ワード」の組み合わせ検知
- **設計可能性**: ✅ 高
- **実装方法**:
  ```sql
  -- 擬似ロジック
  WHERE sentiment_score < -0.3 
    AND (
      REGEXP_CONTAINS(subject, r'(進捗|返信|ご回答|お返事|確認|お願い)') 
      OR REGEXP_CONTAINS(body_preview, r'(進捗|返信|ご回答|お返事|確認|お願い)')
    )
    AND sentiment_score < (
      SELECT AVG(sentiment_score) 
      FROM unified_email_messages 
      WHERE thread_id = u.thread_id 
        AND datetime < u.datetime
        AND datetime >= TIMESTAMP_SUB(u.datetime, INTERVAL 30 DAY)
    )
  ```
- **技術的難易度**: 低（SQL + 正規表現）
- **実装工数**: 0.5人日

#### 2. 「72時間放置で検知」ルール
- **設計可能性**: ✅ 高
- **実装方法**:
  ```sql
  WITH LatestActivity AS (
    SELECT 
      thread_id,
      MAX(datetime) as last_activity,
      MAX(datetime) = MAX(CASE WHEN direction = 'inbound' THEN datetime END) as customer_last_replied
    FROM unified_email_messages
    GROUP BY thread_id
  )
  SELECT *
  FROM LatestActivity
  WHERE 
    TIMESTAMP_DIFF(CURRENT_TIMESTAMP(), last_activity, HOUR) >= 72
    AND customer_last_replied = TRUE
  ```
- **技術的難易度**: 低（SQL集計）
- **実装工数**: 0.5人日

#### 3. 「夜間返信率50%越」異常検知
- **設計可能性**: ✅ 高
- **実装方法**:
  ```sql
  WITH ReplyStats AS (
    SELECT 
      person,
      COUNT(*) as total_replies,
      COUNTIF(EXTRACT(HOUR FROM datetime) >= 22 OR EXTRACT(HOUR FROM datetime) < 6) as night_replies,
      COUNTIF(EXTRACT(HOUR FROM datetime) >= 22 OR EXTRACT(HOUR FROM datetime) < 6) * 100.0 / COUNT(*) as night_rate
    FROM unified_email_messages
    WHERE direction = 'outbound'
      AND datetime >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)
    GROUP BY person
  ),
  Baseline AS (
    SELECT 
      person,
      AVG(night_rate) as avg_night_rate
    FROM (
      SELECT 
        person,
        DATE(datetime) as day,
        COUNTIF(EXTRACT(HOUR FROM datetime) >= 22 OR EXTRACT(HOUR FROM datetime) < 6) * 100.0 / COUNT(*) as night_rate
      FROM unified_email_messages
      WHERE direction = 'outbound'
        AND datetime >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 90 DAY)
        AND datetime < TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)
      GROUP BY person, day
    )
    GROUP BY person
  )
  SELECT 
    r.person,
    r.night_rate,
    b.avg_night_rate,
    r.night_rate - b.avg_night_rate as deviation
  FROM ReplyStats r
  LEFT JOIN Baseline b ON r.person = b.person
  WHERE r.night_rate >= 50 
     OR (r.night_rate - COALESCE(b.avg_night_rate, 20)) >= 30
  ```
- **技術的難易度**: 中（時系列比較ロジック）
- **実装工数**: 1人日

#### 4. 「トーンダウン + 返信頻度変化」の組み合わせ検知
- **設計可能性**: ✅ 高
- **実装方法**:
  ```sql
  WITH SentimentTrend AS (
    SELECT 
      person,
      AVG(CASE 
        WHEN datetime >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY) 
        THEN sentiment_score 
      END) as recent_sentiment,
      AVG(CASE 
        WHEN datetime >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY)
          AND datetime < TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)
        THEN sentiment_score 
      END) as past_sentiment
    FROM unified_email_messages
    WHERE sentiment_score IS NOT NULL
    GROUP BY person
  ),
  ReplyFrequencyTrend AS (
    SELECT 
      person,
      COUNT(*) / 7.0 as recent_daily_reply_rate,
      (
        SELECT COUNT(*) / 23.0
        FROM unified_email_messages
        WHERE person = u.person
          AND direction = 'outbound'
          AND datetime >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY)
          AND datetime < TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)
      ) as past_daily_reply_rate
    FROM unified_email_messages u
    WHERE direction = 'outbound'
      AND datetime >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)
    GROUP BY person
  )
  SELECT 
    s.person,
    s.recent_sentiment - s.past_sentiment as sentiment_drop,
    r.recent_daily_reply_rate - r.past_daily_reply_rate as frequency_drop
  FROM SentimentTrend s
  JOIN ReplyFrequencyTrend r ON s.person = r.person
  WHERE (s.recent_sentiment - s.past_sentiment) < -0.2
    AND (r.recent_daily_reply_rate - r.past_daily_reply_rate) < -0.5
  ```
- **技術的難易度**: 中（複合指標の計算）
- **実装工数**: 1.5人日

#### 5. 「催促（進捗いかがでしょ）」の具体的検知
- **設計可能性**: ✅ 中（パターン定義が必要）
- **実装方法**:
  - 正規表現パターン辞書の作成:
    ```javascript
    const inquiryPatterns = [
      /進捗(いかが|どう|どうですか|でしょうか)/,
      /お返事(いただけます|いただければ|お願いします)/,
      /確認(させていただきたいのですが|させてください)/,
      /(念のため|一応|恐れ入りますが).*確認/,
      /(お忙しいところ|ご多忙の中).*(ですが|申し訳ございませんが|恐縮ですが)/,
    ]
    ```
  - `lib/keyword-detector.ts` を拡張
- **技術的難易度**: 低（パターン追加のみ）
- **実装工数**: 0.5人日（パターン定義） + 0.5人日（実装）

#### 6. 「不安・違和感」の具体的検知
- **設計可能性**: ✅ 高（フレーズパターンマッチング）
- **実装方法**:
  - 「念のため確認ですが」系フレーズの辞書作成
  - 既存の `keyword-detector.ts` に追加
- **技術的難易度**: 低
- **実装工数**: 0.5人日

#### 7. 予兆検知（アラート前段階）
- **設計可能性**: ✅ 中（閾値設計が難しい）
- **実装方法**:
  - 過去7日 vs 過去30日の送受信頻度を比較
  - 急激な変化率（例: 30%減）を閾値として設定
- **技術的難易度**: 中（閾値チューニングが必要）
- **実装工数**: 1.5人日（ロジック実装 + チューニング）

### ⚠️ 実装可能だが追加データ・設計が必要な機能

#### 1. 対応品質の定量化
- **設計可能性**: ✅ 中（NLP計算ロジックが必要）
- **実装方法**:
  - 既存の `lib/japanese-nlp-analyzer.ts` を拡張
  - 丁寧語スコア、質問への回答率、文字数などを計算
- **技術的難易度**: 中
- **実装工数**: 2人日（NLPロジック追加）

#### 2. 「本質改善もしくは、リソース分配」の推奨アクション
- **設計可能性**: ⚠️ 中（判断基準の定義が必要）
- **実装方法**:
  - 複数指標の組み合わせで判断:
    - 対応時間が長い + 夜間返信率高い → リソース不足
    - 対応時間が長い + 感情スコア悪化 → スキル不足またはリソース不足
    - 顧客からの再問い合わせ多い → 対応品質問題
  - LLMによる推奨アクション生成時に、上記判断をプロンプトに含める
- **技術的難易度**: 中（判断基準の設計が必要）
- **実装工数**: 2人日（基準定義 + LLMプロンプト設計）

---

## 3. 各検知モデル作成時の現状コスト想定

### ツール利用費・サーバー代の内訳

#### ベースインフラ（共通）
- **VM（小規模推論用）**: 2〜4万円/月
  - CPU 4core, RAM 8GB, ストレージ 100GB
  - 使用目的: バッチ処理、推論API、軽量MLモデル実行

#### 各検知機能別の追加コスト

##### 1. 「感情ダウン + 催促ワード」組み合わせ検知
- **追加ツール**: なし（SQL集計のみ）
- **追加コスト**: **0円/月**
- **実装コスト**: 0.5人日（約4万円@時給1万円）

##### 2. 「72時間放置で検知」ルール
- **追加ツール**: なし（SQL集計のみ）
- **追加コスト**: **0円/月**
- **実装コスト**: 0.5人日（約4万円）

##### 3. 「夜間返信率50%越」異常検知
- **追加ツール**: なし（SQL集計のみ）
- **追加コスト**: **0円/月**
- **実装コスト**: 1人日（約8万円）

##### 4. 「トーンダウン + 返信頻度変化」組み合わせ検知
- **追加ツール**: なし（SQL集計のみ）
- **追加コスト**: **0円/月**
- **実装コスト**: 1.5人日（約12万円）

##### 5. 「催促（進捗いかがでしょ）」具体的検知
- **追加ツール**: なし（パターンマッチングのみ）
- **追加コスト**: **0円/月**
- **実装コスト**: 1人日（約8万円）

##### 6. 「不安・違和感」具体的検知
- **追加ツール**: なし（パターンマッチングのみ）
- **追加コスト**: **0円/月**
- **実装コスト**: 0.5人日（約4万円）

##### 7. 予兆検知（アラート前段階）
- **追加ツール**: なし（SQL集計のみ）
- **追加コスト**: **0円/月**
- **実装コスト**: 1.5人日（約12万円）

##### 8. 対応品質の定量化
- **追加ツール**: 
  - NLPライブラリ（spaCy日本語モデル）: 既存使用、追加コストなし
  - 計算処理のCPU負荷: ベースインフラ内
- **追加コスト**: **0円/月**（既存NLPインフラ活用）
- **実装コスト**: 2人日（約16万円）

##### 9. 「本質改善もしくは、リソース分配」推奨アクション
- **追加ツール**: 
  - LLM API（OpenAI GPT-4等）: 1回あたり約10-50円、月1000回利用想定で **0.5〜2.5万円/月**
- **追加コスト**: **0.5〜2.5万円/月**
- **実装コスト**: 2人日（約16万円）

##### 10. 「ポール（本質）明確にし、返信判断」アクション
- **追加ツール**: 
  - LLM API: 1回あたり約10-30円、月500回利用想定で **0.5〜1.5万円/月**
- **追加コスト**: **0.5〜1.5万円/月**
- **実装コスト**: 1.5人日（約12万円）

##### 11. 「不安解消フォロー」アクション
- **追加ツール**: 
  - LLM API: 1回あたり約5-20円、月500回利用想定で **0.25〜1万円/月**
- **追加コスト**: **0.25〜1万円/月**
- **実装コスト**: 1人日（約8万円）

##### 12. 「返信文や、ワードチョイスの改善」アクション
- **追加ツール**: 
  - LLM API: 1回あたり約10-40円、月300回利用想定で **0.3〜1.2万円/月**
- **追加コスト**: **0.3〜1.2万円/月**
- **実装コスト**: 1.5人日（約12万円）

##### 13. 「返信フォロー」アクション
- **追加ツール**: なし（対応履歴の時系列分析のみ）
- **追加コスト**: **0円/月**
- **実装コスト**: 1人日（約8万円）

### 全体コスト試算（プロトタイプ段階）

#### 最小構成（SQLベース検知のみ）
- **ベースインフラ**: 2〜4万円/月
- **追加ツール**: 0円/月
- **合計**: **2〜4万円/月**
- **実装コスト合計**: 約6.5人日（約52万円）

#### 標準構成（SQL + NLP拡張）
- **ベースインフラ**: 2〜4万円/月
- **LLM API（推奨アクション生成）**: 1.5〜5万円/月（利用頻度による）
- **合計**: **3.5〜9万円/月**
- **実装コスト合計**: 約15人日（約120万円）

#### フル構成（全検知機能 + LLM活用）
- **ベースインフラ**: 2〜4万円/月
- **LLM API（全推奨アクション）**: 1.5〜6万円/月
- **合計**: **3.5〜10万円/月**
- **実装コスト合計**: 約20人日（約160万円）

### コスト削減のポイント

1. **LLM APIの利用頻度調整**
   - 全件で生成するのではなく、重要度が高い検知のみLLMを呼び出し
   - テンプレートベースの推奨アクションを優先し、例外ケースのみLLM使用
   - 月額コストを **1〜3万円/月** に抑え可能

2. **バッチ処理の最適化**
   - 日次バッチで検知結果を事前計算し、リアルタイム処理は最小限に
   - ベースインフラのCPU利用率を下げ、より小さなインスタンスで運用可能

3. **段階的実装**
   - Phase 1: SQLベース検知のみ（コスト2〜4万円/月）
   - Phase 2: NLP拡張追加（コスト3.5〜9万円/月）
   - Phase 3: LLM活用追加（コスト3.5〜10万円/月）

---

## 結論

### 1. 不足データの補完
- **✅ 大部分のデータは既存テーブルで補完可能**
- ⚠️ 対応品質の定量化、リソース分配判断は新規計算が必要
- ❌ 顧客満足度の直接データ、スキルレベルデータは現状未取得

### 2. 検知機能の設計可能性
- **✅ SQLベース検知機能（1〜7）: 設計・実装可能**
- **⚠️ NLP拡張機能（8）: 実装可能だが追加開発が必要**
- **⚠️ LLM活用機能（9〜12）: 実装可能だがプロンプト設計とコスト管理が必要**

### 3. コスト想定（プロトタイプ段階）
- **最小構成**: 2〜4万円/月（実装コスト約52万円）
- **標準構成**: 3.5〜9万円/月（実装コスト約120万円）
- **フル構成**: 3.5〜10万円/月（実装コスト約160万円）

**推奨**: 段階的実装で、Phase 1（SQLベース検知のみ）から開始し、効果を確認しながらLLM機能を追加することを推奨。

---

更新履歴
- 2025-10-24 初稿作成


